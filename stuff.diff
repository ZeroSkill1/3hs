diff --git a/3rd/3rd/json.hh b/3rd/3rd/json.hh
index ae17768..1ecef96 100644
--- a/3rd/3rd/json.hh
+++ b/3rd/3rd/json.hh
@@ -2257,7 +2257,7 @@ JSON_HEDLEY_DIAGNOSTIC_POP
     #define JSON_INTERNAL_CATCH(exception) catch(exception)
 #else
     #include <cstdlib>
-    #define JSON_THROW(exception) std::abort()
+    #define JSON_THROW(exception) panic(exception.what())
     #define JSON_TRY if(true)
     #define JSON_CATCH(exception) if(false)
     #define JSON_INTERNAL_CATCH(exception) if(false)
diff --git a/include/find_missing.hh b/include/find_missing.hh
index c5ee2ae..9be05f7 100644
--- a/include/find_missing.hh
+++ b/include/find_missing.hh
@@ -2,7 +2,11 @@
 #ifndef inc_find_missing_hh
 #define inc_find_missing_hh
 
-void show_find_missing();
+#include "hsapi.hh"
+
+
+void show_find_missing(hsapi::htid tid = 0x0);
+bool tid_can_have_missing(hsapi::htid tid);
 
 #endif
 
diff --git a/include/hsapi.hh b/include/hsapi.hh
index 5e6c0f5..05e6e55 100644
--- a/include/hsapi.hh
+++ b/include/hsapi.hh
@@ -69,6 +69,9 @@ namespace hsapi
 		hsize size; /* filesize */
 		htid tid; /* title id of the title */
 		hid id; /* hShop id */
+
+		friend bool operator == (const Title& lhs, const Title& rhs)
+		{ return lhs.id == rhs.id; }
 	} Title;
 
 	typedef struct FullTitle : public Title
@@ -103,6 +106,20 @@ namespace hsapi
 	std::string parse_vstring(hiver ver);
 	Index *get_index();
 
+	// Silent call. ui::loading() is not called and it will stop after 3 tries
+	template <typename ... Ts>
+	Result scall(Result (*func)(Ts...), Ts&& ... args)
+	{
+		Result res = 0;
+		int tries = 0;
+
+		do {
+			res = (*func)(args...);
+			++tries;
+		} while(R_FAILED(res) && tries < 3);
+		return res;
+	}
+
 	// NOTE: You have to std::move() primitives (hid, hiver, htid, ...)
 	template <typename ... Ts>
 	Result call(Result (*func)(Ts...), Ts&& ... args)
diff --git a/include/i18n.hh b/include/i18n.hh
index f7754f7..522ff95 100644
--- a/include/i18n.hh
+++ b/include/i18n.hh
@@ -99,6 +99,8 @@ namespace str
 		retry_req = 74,
 		search_zero_results = 75,
 		credits = 76,
+		extra_content = 77,
+		ask_extra = 78,
 
 		_i_max,
 	};
diff --git a/include/install.hh b/include/install.hh
index b03c7c3..aa05185 100644
--- a/include/install.hh
+++ b/include/install.hh
@@ -15,13 +15,14 @@ enum Destination
 };
 
 typedef std::function<void(u64 /* done */, u64 /* total */)> prog_func;
-typedef std::function<std::string()> get_url_func;
+typedef std::function<std::string(Result&)> get_url_func;
 static void default_prog_func(u64, u64)
 { }
 
 static inline get_url_func makeurlwrap(const std::string& url)
 {
-	return [url]() -> std::string {
+	return [url](Result& r) -> std::string {
+		r = 0;
 		return url;
 	};
 }
diff --git a/include/queue.hh b/include/queue.hh
index 4efd510..4f61256 100644
--- a/include/queue.hh
+++ b/include/queue.hh
@@ -9,13 +9,15 @@
 
 
 Result process_uri(const std::string& uri, bool reinstallable = false, const std::string& tid = "", FS_MediaType media = MEDIATYPE_SD);
-Result process_hs(hsapi::FullTitle& meta, bool reinstall = false);
+Result process_hs(hsapi::FullTitle& meta, bool interactive = true, bool reinstall = false);
 Result process_hs(hsapi::hid id);
 
+std::vector<hsapi::FullTitle>& queue_get();
+
+void queue_add(hsapi::hid id, bool disp = true);
 void queue_add(const hsapi::FullTitle& meta);
 void queue_process(size_t index);
 void queue_remove(size_t index);
-void queue_add(hsapi::hid id);
 void queue_process_all();
 void queue_clear();
 void show_queue();
diff --git a/include/settings.hh b/include/settings.hh
index 765bd45..775122d 100644
--- a/include/settings.hh
+++ b/include/settings.hh
@@ -37,6 +37,7 @@ typedef struct Settings
 	ProgressBarLocation progloc = ProgressBarLocation::bottom;
 	lang::type language = lang::english;
 	LumaLocaleMode lumalocalemode = LumaLocaleMode::automatic;
+	bool askForExtraContent = true;
 } Settings;
 
 
diff --git a/source/find_missing.cc b/source/find_missing.cc
index 0c08022..8131c97 100644
--- a/source/find_missing.cc
+++ b/source/find_missing.cc
@@ -17,21 +17,28 @@ template <typename T>
 static void vecappend(std::vector<T>& a, const std::vector<T>& b)
 { a.insert(a.end(), b.begin(), b.end()); }
 
-void show_find_missing()
+bool tid_can_have_missing(hsapi::htid tid)
+{
+	u16 category = (tid >> 32) & 0xFFFF;
+	return category == 0x0000 /* normal */ || category == 0x8000 /* DSiWare/TWL */;
+}
+
+void show_find_missing(hsapi::htid tid)
 {
 	toggle_focus();
 
-	ui::loading([]() -> void {
+	ui::loading([tid]() -> void {
 
-		std::vector<u64> installed;
+		std::vector<hsapi::htid> installed;
 		panic_if_err_3ds(list_titles_on(MEDIATYPE_SD, installed));
 		list_titles_on(MEDIATYPE_GAME_CARD, installed); // it might error if there is no cart inserted so we don't want to panic if it fails
 
-		std::vector<u64> installedGames;
-		std::copy_if(installed.begin(), installed.end(), std::back_inserter(installedGames), [](u64 tid) -> bool {
-			u16 category = (tid >> 32) & 0xFFFF;
-			return category == 0x0000 /* normal */ || category == 0x8000 /* DSiWare/TWL */;
-		});
+		std::vector<hsapi::htid> doCheckOn;
+		if(tid == 0) doCheckOn = installed;
+		else doCheckOn.push_back(tid);
+
+		std::vector<hsapi::htid> installedGames;
+		std::copy_if(doCheckOn.begin(), doCheckOn.end(), std::back_inserter(installedGames), tid_can_have_missing);
 
 		hsapi::BatchRelated related;
 		if(R_FAILED(hsapi::batch_related(related, installedGames)))
@@ -48,11 +55,14 @@ void show_find_missing()
 		std::vector<hsapi::Title> newInstalls;
 		std::copy_if(potentialInstalls.begin(), potentialInstalls.end(), std::back_inserter(newInstalls), [installed](const hsapi::Title& title) -> bool {
 			// TODO: also check the version int, wait for backend update to return version int for that
-			return std::find(installed.begin(), installed.end(), title.tid) != installed.end();
+			// Is the title already installed?
+			return std::find(installed.begin(), installed.end(), title.tid) == installed.end()
+				// Is the title already in the queue?
+				&& std::find(queue_get().begin(), queue_get().end(), title) == queue_get().end();
 		});
 
 		for(const hsapi::Title& title : newInstalls)
-			queue_add(title.id);
+			queue_add(title.id, false);
 
 	});
 
diff --git a/source/hsapi.cc b/source/hsapi.cc
index 3ba5fc2..ef0059e 100644
--- a/source/hsapi.cc
+++ b/source/hsapi.cc
@@ -12,7 +12,6 @@
 #define SOC_ALIGN       0x100000
 #define SOC_BUFFERSIZE  0x20000
 
-#define HS_CDN_BASE_API "https://download4.erista.me" // This one has https :/
 #define HS_UPDATE_BASE  "http://download2.erista.me/3hs"
 #define HS_CDN_BASE     "http://download4.erista.me"
 #define HS_BASE_LOC     "https://hshop.erista.me/api"
@@ -43,7 +42,8 @@ static Result basereq(const std::string& url, std::string& data, HTTPC_RequestMe
 	TRY(httpcSetSSLOpt(&ctx, SSLCOPT_DisableVerify));
 	TRY(httpcSetKeepAlive(&ctx, HTTPC_KEEPALIVE_ENABLED));
 	TRY(httpcAddRequestHeaderField(&ctx, "Connection", "Keep-Alive"));
-	TRY(httpcAddTrustedRootCA(&ctx, hscert_der, hscert_der_len));
+	if(url.find("https") == 0) // only use certs on https
+		TRY(httpcAddTrustedRootCA(&ctx, hscert_der, hscert_der_len));
 	TRY(proxy::apply(&ctx));
 
 	TRY(httpcBeginRequest(&ctx));
@@ -66,8 +66,7 @@ static Result basereq(const std::string& url, std::string& data, HTTPC_RequestMe
 
 	u32 totalSize = 0;
 	TRY(httpcGetDownloadSizeState(&ctx, nullptr, &totalSize));
-	if(totalSize == 0) return APPERR_NOSIZE;
-	data.reserve(totalSize);
+	if(totalSize != 0) data.reserve(totalSize);
 
 	char buffer[4096];
 	u32 dled = 0;
@@ -280,7 +279,7 @@ Result hsapi::get_download_link(std::string& ret, const hsapi::Title& meta)
 {
 	json j;
 	Result res = OK;
-	if(R_FAILED(res = basereq<json>(HS_CDN_BASE_API "/content/request?id=" + std::to_string(meta.id), j)))
+	if(R_FAILED(res = basereq<json>(HS_CDN_BASE "/content/request?id=" + std::to_string(meta.id), j)))
 		return res;
 
 	ret = HS_CDN_BASE "/content/" + std::to_string(meta.id) + "?token=" + j["token"].get<std::string>();
diff --git a/source/i18n.cc b/source/i18n.cc
index 38616c1..67c2d22 100644
--- a/source/i18n.cc
+++ b/source/i18n.cc
@@ -108,6 +108,8 @@ static const char *strtab[lang::_i_max][str::_i_max] =
 			[str::retry_req] = "Request failed. Do you want to retry?",
 			[str::search_zero_results] = "Search gave 0 results\nPress " GLYPH_A " to go back",
 			[str::credits] = "Credits",
+			[str::extra_content] = "Add extra content to queue?",
+			[str::ask_extra] = "Ask for extra content",
 		},
 
 	[lang::dutch] =
@@ -207,6 +209,8 @@ static const char *strtab[lang::_i_max][str::_i_max] =
 			[str::retry_req] ="Opnieuw proberen gegevens te halen?",
 			[str::search_zero_results] =  "Zoekopdracht gaf 0 resultaten\nKlik op " GLYPH_A " om terug te gaan",
 			[str::credits] = "Met dank aan",
+			STUB(extra_content),
+			STUB(ask_extra),
 		},
 
 	[lang::german] =
@@ -303,6 +307,8 @@ static const char *strtab[lang::_i_max][str::_i_max] =
 			[str::retry_req] = "Erneut versuchen?",
 			[str::search_zero_results] = "Suche ergab keine Ergebnisse\nDrücke " GLYPH_A " um zurückzukehren",
 			[str::credits] = "Mitwirkende",
+			STUB(extra_content),
+			STUB(ask_extra),
 		},
 
 	[lang::spanish] =
@@ -400,6 +406,8 @@ static const char *strtab[lang::_i_max][str::_i_max] =
 			[str::retry_req] = "¿Quieres reintentar?",
 			[str::search_zero_results] = "La búsqueda no dió resultados\nPresiona " GLYPH_A " para regresar",
 			[str::credits] = "Créditos",
+			STUB(extra_content),
+			STUB(ask_extra),
 		},
 };
 #pragma GCC diagnostic pop
diff --git a/source/install.cc b/source/install.cc
index c3b8b0f..6015eb9 100644
--- a/source/install.cc
+++ b/source/install.cc
@@ -114,9 +114,9 @@ static Result i_install_net_cia(std::string url, cia_net_data *data, size_t from
 	return 0;
 }
 
-static void i_install_loop_thread_cb(Result& res, std::function<std::string()> get_url, cia_net_data& data)
+static void i_install_loop_thread_cb(Result& res, get_url_func get_url, cia_net_data& data)
 {
-	std::string url = get_url();
+	std::string url = get_url(res);
 	linfo << "Installing cia from <" << url << ">.";
 
 	if(!get_settings()->resumeDownloads)
@@ -129,7 +129,7 @@ static void i_install_loop_thread_cb(Result& res, std::function<std::string()> g
 	while(true)
 	{
 		if(url != "") // url == "" means we failed to fetch the url
-			res = i_install_net_cia(get_url(), &data, data.index);
+			res = i_install_net_cia(get_url(res), &data, data.index);
 
 		// User pressed start
 		if(data.itc == ITC::exit)
@@ -154,15 +154,16 @@ static void i_install_loop_thread_cb(Result& res, std::function<std::string()> g
 			}
 
 			data.itc = ITC::normal;
-			url = get_url();
+			url = get_url(res);
 			continue;
 		}
 
+		// Installation was a fail, so we stop
 		break;
 	}
 }
 
-static Result i_install_resume_loop(std::function<std::string()> get_url, Handle ciaHandle, prog_func prog)
+static Result i_install_resume_loop(get_url_func get_url, Handle ciaHandle, prog_func prog)
 {
 	cia_net_data data;
 	data.buffer = new u8[BUFSIZE];
@@ -171,7 +172,7 @@ static Result i_install_resume_loop(std::function<std::string()> get_url, Handle
 	Result res = 0;
 
 	// Install thread
-	thread<Result&, std::function<std::string()>, cia_net_data&> th
+	thread<Result&, get_url_func, cia_net_data&> th
 		(i_install_loop_thread_cb, res, get_url, data);
 
 	// UI Loop
@@ -245,9 +246,9 @@ static Result i_install_hs_cia(hsapi::FullTitle *meta, prog_func prog, bool rein
 	if(!isNew && meta->prod.rfind("KTR-", 0) == 0)
 		return APPERR_NOSUPPORT;
 
-	return install_net_cia([meta]() -> std::string {
+	return install_net_cia([meta](Result& res) -> std::string {
 		std::string ret;
-		if(R_FAILED(hsapi::get_download_link(ret, *meta)))
+		if(R_FAILED(res = hsapi::get_download_link(ret, *meta)))
 			return "";
 		return ret;
 	}, prog, reinstallable, meta->tid, to_mediatype(media));
diff --git a/source/main.cc b/source/main.cc
index cbc1e49..8de8fe5 100644
--- a/source/main.cc
+++ b/source/main.cc
@@ -213,11 +213,13 @@ int main(int argc, char* argv[])
 	if(R_FAILED(res))
 	{
 		error_container errcont = get_error(res);
-		lfatal << "Failed to fetch index, dns fucked? Server down? " << errcont.sDesc << "\n";
+		report_error(errcont, "Failed to fetch index, dns fucked? Server down?");
 		panic(PSTRING(fail_fetch_index, errcont.sDesc));
 		return 3;
 	}
 
+	lverbose << "Done fetching index.";
+
 	// Old logic was cursed, made it a bit better :blobaww:
 	while(aptMainLoop())
 	{
diff --git a/source/more.cc b/source/more.cc
index b2bcff7..c6e0f93 100644
--- a/source/more.cc
+++ b/source/more.cc
@@ -10,9 +10,12 @@
 #include <ui/image_button.hh>
 #include <ui/button.hh>
 
-#define ABOUT_I 0
-#define FIND_MISSING_I 1
-#define HELP_I 2
+enum MoreInds {
+	IND_ABOUT = 0,
+	IND_FIND_MISSING,
+	IND_HELP,
+	IND_MAX
+};
 
 #define Y1 (10)
 #define Y2 (SCREEN_WIDTH(ui::Scr::bottom) - 10)
@@ -36,48 +39,47 @@ void show_more()
 {
 	enter_exit();
 
-	constexpr size_t maxIndex = 4;
 	size_t index = 0;
 
-	ui::Button *buttons[maxIndex];
+	ui::Button *buttons[IND_MAX];
 
 	// Create buttons
-	ui::Button *about = new ui::Button(STRING(about_app), Y1, X1(ABOUT_I), Y2, X2(ABOUT_I));
-	ui::Button *find_missing = new ui::Button(STRING(find_missing_content), Y1, X1(FIND_MISSING_I),
-		Y2, X2(FIND_MISSING_I));
-	ui::Button *help = new ui::Button(STRING(help_manual), Y1, X1(HELP_I), Y2, X2(HELP_I));
+	ui::Button *about = new ui::Button(STRING(about_app), Y1, X1(IND_ABOUT), Y2, X2(IND_ABOUT));
+	ui::Button *find_missing = new ui::Button(STRING(find_missing_content), Y1, X1(IND_FIND_MISSING),
+		Y2, X2(IND_FIND_MISSING));
+	ui::Button *help = new ui::Button(STRING(help_manual), Y1, X1(IND_HELP), Y2, X2(IND_HELP));
 
 	// Setup buttons
 	about->highlight();
 
 	about->set_on_click([&index, &buttons](bool inFrame) -> ui::Results {
 		if(inFrame) ui::end_frame();
-		set_hi(&index, buttons, ABOUT_I); show_about();
+		set_hi(&index, buttons, IND_ABOUT); show_about();
 		return ui::Results::end_early;
 	});
 
 	find_missing->set_on_click([&index, &buttons](bool inFrame) -> ui::Results {
 		if(inFrame) ui::end_frame();
-		set_hi(&index, buttons, FIND_MISSING_I);
+		set_hi(&index, buttons, IND_FIND_MISSING);
 		return ui::Results::end_early;
 	});
 
 	help->set_on_click([&index, &buttons](bool inFrame) -> ui::Results {
 		if(inFrame) ui::end_frame();
-		set_hi(&index, buttons, HELP_I); show_help();
+		set_hi(&index, buttons, IND_HELP); show_help();
 		return ui::Results::end_early;
 	});
 
 	find_missing->set_on_click([&index, &buttons](bool inFrame) -> ui::Results {
 		if(inFrame) ui::end_frame();
-		set_hi(&index, buttons, HELP_I); show_find_missing();
+		set_hi(&index, buttons, IND_HELP); show_find_missing();
 		return ui::Results::end_early;
 	});
 
 	// Setup indices
-	buttons[ABOUT_I]        = about;
-	buttons[FIND_MISSING_I] = find_missing;
-	buttons[HELP_I]         = help;
+	buttons[IND_ABOUT]        = about;
+	buttons[IND_FIND_MISSING] = find_missing;
+	buttons[IND_HELP]         = help;
 
 	ui::Widgets wids;
 	wids.push_back(about, ui::Scr::bottom);
@@ -88,7 +90,7 @@ void show_more()
 	while(ui::framenext(keys))
 	{
 		if(!ui::framedraw(wids, keys)) break;
-		if(keys.kDown & KEY_DOWN && index < maxIndex - 1)
+		if(keys.kDown & KEY_DOWN && index < IND_MAX - 1)
 		{
 			buttons[index]->highlight(false);
 			buttons[index + 1]->highlight();
diff --git a/source/next.cc b/source/next.cc
index 6cacb02..03c229b 100644
--- a/source/next.cc
+++ b/source/next.cc
@@ -108,7 +108,12 @@ hsapi::hid next::sel_gam(std::vector<hsapi::Title>& titles)
 				return ui::Results::quit_no_end;
 			}
 			else if(keys & KEY_Y)
+			{
+				// it does some drawing :yeehad:
+				ui::end_frame();
 				queue_add(self->at(index).id);
+				return ui::Results::end_early;
+			}
 
 			return ui::Results::go_on;
 		}, titles
diff --git a/source/queue.cc b/source/queue.cc
index d0477e8..ddbbdb5 100644
--- a/source/queue.cc
+++ b/source/queue.cc
@@ -15,6 +15,7 @@
 
 #include <vector>
 
+#include "find_missing.hh"
 #include "lumalocale.hh"
 #include "install.hh"
 #include "panic.hh"
@@ -23,17 +24,18 @@
 #include "util.hh"
 
 static std::vector<hsapi::FullTitle> g_queue;
-
+std::vector<hsapi::FullTitle>& queue_get() { return g_queue; }
 
 void queue_add(const hsapi::FullTitle& meta)
 {
 	g_queue.push_back(meta);
 }
 
-void queue_add(hsapi::hid id)
+void queue_add(hsapi::hid id, bool disp)
 {
 	hsapi::FullTitle meta;
-	Result res = hsapi::call(hsapi::title_meta, meta, std::move(id));
+	Result res = disp ? hsapi::call(hsapi::title_meta, meta, std::move(id))
+		: hsapi::scall(hsapi::title_meta, meta, std::move(id));
 	if(R_FAILED(res)) return;
 	queue_add(meta);
 }
@@ -62,7 +64,7 @@ void queue_process_all()
 	toggle_focus();
 	for(hsapi::FullTitle& meta : g_queue)
 	{
-		if(R_FAILED(process_hs(meta)))
+		if(R_FAILED(process_hs(meta, false)))
 			break;
 	}
 	luma::set_gamepatching();
@@ -116,7 +118,7 @@ Result process_hs(hsapi::hid id)
 	return process_hs(meta);
 }
 
-Result process_hs(hsapi::FullTitle& meta, bool reinstall)
+Result process_hs(hsapi::FullTitle& meta, bool interactive, bool reinstall)
 {
 	ui::Widgets wids;
 	ui::ProgressBar *bar = new ui::ProgressBar(0, 1); // = 0%
@@ -140,7 +142,7 @@ Result process_hs(hsapi::FullTitle& meta, bool reinstall)
 		generic_main_breaking_loop(rei);
 
 		if(userWantsReinstall)
-			return process_hs(meta, true);
+			return process_hs(meta, interactive, true);
 	}
 
 	// Error!
@@ -151,6 +153,19 @@ Result process_hs(hsapi::FullTitle& meta, bool reinstall)
 		handle_error(err);
 	}
 
+	// Prompt to ask for extra content
+	else if(interactive && tid_can_have_missing(meta.tid) && get_settings()->askForExtraContent)
+	{
+		bool findMissing = true;
+
+		ui::Widgets ext;
+		ext.push_back(new ui::Confirm(STRING(extra_content), findMissing), ui::Scr::bottom);
+		generic_main_breaking_loop(ext);
+
+		if(findMissing)
+			show_find_missing(meta.tid);
+	}
+
 	ui::wid()->get<ui::FreeSpaceIndicator>("size_indicator")->update();
 	return res;
 }
@@ -183,7 +198,8 @@ void show_queue()
 		[](ui::List<hsapi::FullTitle> *self, size_t index, u32 keys) -> ui::Results {
 			if(keys & KEY_X)
 			{
-				if(self->out_of_bounds(index)) return ui::Results::go_on;
+				if(self->out_of_bounds(index))
+					return ui::Results::go_on;
 				queue_remove(index);
 				self->update_text_reg();
 				if(g_queue.size() != 0 && self->get_pointer() >= g_queue.size())
@@ -211,9 +227,11 @@ void show_queue()
 
 	wids.push_back("install_all", new ui::Button("Install All", 10, 180, 100, 200), ui::Scr::bottom);
 	wids.get<ui::Button>("install_all")->set_on_click([list](bool) -> ui::Results {
-		queue_process_all(); list->update_text_reg();
+		ui::end_frame();
+		queue_process_all();
+		list->update_text_reg();
 		queue_is_empty(false);
-		return ui::Results::quit_loop;
+		return ui::Results::quit_no_end;
 	});
 
 	ui::Button *installSel = new ui::Button("Install Selected", 10, 210, 150, 230);
@@ -221,19 +239,22 @@ void show_queue()
 
 	installSel->set_on_click([list](bool) -> ui::Results {
 		if(list->out_of_bounds(list->get_pointer())) return ui::Results::go_on;
-		queue_process(list->get_pointer()); list->update_text_reg();
+		ui::end_frame();
+		queue_process(list->get_pointer());
+		list->update_text_reg();
 		if(g_queue.size() == 0)
 		{
 			queue_is_empty(false);
-			return ui::Results::quit_loop;
+			return ui::Results::quit_no_end;
 		}
-		return ui::Results::go_on;
+		list->set_pointer(list->get_pointer() - 1);
+		return ui::Results::end_early;
 	}); installSel->toggle_click();
+
 	wids.push_back(new ui::DoAfterFrames(20, [installSel]() -> ui::Results {
 		installSel->toggle_click(); return ui::Results::go_on;
 	}));
 
-
 	generic_main_breaking_loop(wids);
 	toggle_focus();
 }
diff --git a/source/settings.cc b/source/settings.cc
index 511ce28..0b6c44d 100644
--- a/source/settings.cc
+++ b/source/settings.cc
@@ -78,6 +78,7 @@ enum SettingsId
 	ID_FreeSpace, ID_Battery,
 	ID_TimeFmt, ID_ProgLoc,
 	ID_Language, ID_Localemode,
+	ID_Extra,
 };
 
 typedef struct SettingInfo
@@ -89,14 +90,15 @@ typedef struct SettingInfo
 
 static std::vector<SettingInfo> g_settings_info =
 {
-	{ SURESTRING(light_mode)     , "Turn on light mode. This will change\nthe way most ui elements look."                               , ID_LightMode },
-	{ SURESTRING(resume_dl)      , "Should we start where we\nleft off downloading the first time\nif we failed the first try?"         , ID_Resumable },
-	{ SURESTRING(load_space)     , "Load the free space indicator.\nBootup time should be shorter\nif you disable this on large SDs"    , ID_FreeSpace },
-	{ SURESTRING(show_battery)   , "Toggle visibility of battery in\ntop right corner"                                                  , ID_Battery   },
-	{ SURESTRING(time_format)    , "Your preferred time format.\nEither 24h or 12h."                                                    , ID_TimeFmt   },
-	{ SURESTRING(progbar_screen) , "The screen to draw progress bars on"                                                                , ID_ProgLoc   },
-	{ SURESTRING(language)       , "The language 3hs is in.\nNote that to update all text you might\nneed to restart 3hs"               , ID_Language  },
+	{ SURESTRING(light_mode)     , "Turn on light mode. This will change\nthe way most ui elements look."                               , ID_LightMode  },
+	{ SURESTRING(resume_dl)      , "Should we start where we\nleft off downloading the first time\nif we failed the first try?"         , ID_Resumable  },
+	{ SURESTRING(load_space)     , "Load the free space indicator.\nBootup time should be shorter\nif you disable this on large SDs"    , ID_FreeSpace  },
+	{ SURESTRING(show_battery)   , "Toggle visibility of battery in\ntop right corner"                                                  , ID_Battery    },
+	{ SURESTRING(time_format)    , "Your preferred time format.\nEither 24h or 12h."                                                    , ID_TimeFmt    },
+	{ SURESTRING(progbar_screen) , "The screen to draw progress bars on"                                                                , ID_ProgLoc    },
+	{ SURESTRING(language)       , "The language 3hs is in.\nNote that to update all text you might\nneed to restart 3hs"               , ID_Language   },
 	{ SURESTRING(lumalocalemode) , "The mode LumaLocale autosetter\nuses. Automatic selects a language\nautomatically, manual manually" , ID_Localemode },
+	{ SURESTRING(ask_extra)      , "Ask for extra content after\nan installation."                                                      , ID_Extra      },
 };
 
 static const char *localemode2str(LumaLocaleMode mode)
@@ -133,6 +135,8 @@ static std::string serialize_id(SettingsId ID)
 		return i18n::langname(g_settings.language);
 	case ID_Localemode:
 		return localemode2str(g_settings.lumalocalemode);
+	case ID_Extra:
+		return g_settings.askForExtraContent ? STRING(btrue) : STRING(bfalse);
 	}
 
 	return STRING(unknown);
@@ -172,6 +176,9 @@ static void update_settings_ID(SettingsId ID)
 	case ID_Battery:
 		g_settings.showBattery = !g_settings.showBattery;
 		break;
+	case ID_Extra:
+		g_settings.askForExtraContent = !g_settings.askForExtraContent;
+		break;
 	// Enums
 	case ID_TimeFmt:
 		g_settings.timeFormat = get_enum<Timefmt>(
